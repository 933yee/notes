---
title: 專題
date: 2024-03-17 14:06:11
tags: 
category: 
math: true
---

## Forward Rendering
- 對場景中每個物體進行光柵化，對每一個幾何體計算場景所有燈光
- 計算完後，我們不希望畫出被擋住的物體，所以進行深度測試 (Z-Buffering)，把被擋住的多邊形剔除
- 這樣對於被剃除的物體和當前看不到的燈光的計算會很浪費資源，而且計算樣很大，因此後來出現了 Deferred Rendering

## Deferred Rendering (Deferred Shading)
- 前面有說被剃除的物體和當前看不到的燈光的計算會很浪費資源，延遲渲染就是不要去計算它們
- 增加了一個 Geometric Buffer (G-Buffer)
- 物體先進行深度測試，再把各種數據光柵化到 G-Buffer，光照延遲到最後計算
- G-Buffer 生成後，開始計算光照。每個光照只會對他覆蓋的像素計算一次


不一定 Forward Rendering 就比較爛，還是要看情況使用，像是 VR 就是使用 Forward Rendering，因為 Deferred Rendering 的 G-Buffer 很吃頻寬

## Graphics API Abstraction Layer: Rendering Hardware Interface (RHI)
- 支援各種不同的 Graphics API
- Renderer 建立在這抽象層上面，抽象層隱藏不同資源對特定 API 的實現方式，大部分渲染的程式碼跟 API 無關，且不需要知道底層是用哪種 Graphics API

### FRHIResource
- RHI Resource 的基本類型，可以是 vertex buffers、index buffers 或是 blend states
- 任何 graphic API 的資源都有一個 RHI 封裝

### FRenderResource
- 定義了渲染資源的通用行為模式
- 建立和封裝 FRHIResources
- 我們可以直接建立和操作 RenderResource，它會幫我們建立所需的 FRHIResources(所以 interface 包含 InitRHI 和 ReleaseRHI 等初始化和釋放 RHIResource 的方法)

## Vertex Facrtories
- 將特定類型的 Mesh 的頂點資訊從 CPU 傳給 GPU，然後被 Vertex Shader 使用
- 是一種 FRenderResource，負責獲取資源和資源的數據，將其建立成 FRHIResources。Vertex Factory 封裝這些資源，當要渲染 Mesh 的時候，Renderer 通過 Mesh 的 Vertex Factory 獲取需要的數據。 

[Vertex Factory](https://miro.medium.com/v2/resize:fit:1400/format:webp/1*r2ej5rO4Lmc5oj8PKWPOjQ.jpeg)


### FStaticMeshDataType
- 包含 Vertex Factory 需要的 RHI 資源

LocalVertexFactory 具有一個名為 FDataType 的本地類別，繼承自 FStaticMeshDataType，多了一個 SRV 指針，與 skinned meshes 一起使用。還有一個 Data，用於封裝建立資源所需的東西

![The FStaticMeshDataType class](https://miro.medium.com/v2/resize:fit:2000/format:webp/1*-u4CVI1XPzHpmSxy8aO6xw.png)

### FVertexStreamComponent
- FDataType 中最重要的 instance 是 Stream Component
- 每個 Stream Component 都存一個 Vertex Buffer 的東西，且只有一種 attribute (Position, TextureCoordinates, etc)
- 所以每個 stream 負責一種 vertex data 的 attribute   
- FVertexStreamComponent 就是其中一個，對 Vertex Buffer 和其他 metadata 進行封裝

![The FVertexStreamComponent structure](https://miro.medium.com/v2/resize:fit:2000/format:webp/1*6vVtE25KPwyJY0DQLO4Mhg.png)

補充：上圖中的 Vertex Buffer 是一種 FRenderResource，建立和封裝 FRHIResourece，也就是 FRHIVertexBuffer

### FVertexElement
- 包含 stream 的 data

### FRHIVertexDeclaration
- Vertex Declaration 等同於 RHI resource of an **Input Layout**，描述了不同 vertex data 的不同屬性，像是 position、normal、tangent...


[创建虚幻自定义Mesh组件 | Part 1: 深度解释顶点工厂（Vertex Factory）](https://zhuanlan.zhihu.com/p/361322348)



## Vertex Shader
#### UDeformMeshComponent
##### CreateSceneProxy()
- 這是 override UPrimitiveComponent.h 裡面的函式
- 檢查 PrimitiveComponent.h 裡面的 `FPrimitiveSceneProxy* SceneProxy` 存不存在，存在就回傳，不存在就回傳 `new FDeformMeshSceneProxy(this)`
  - `FDeformMeshSceneProxy` 是自定義的 proxy
```cpp
FPrimitiveSceneProxy* UDeformMeshComponent::CreateSceneProxy()
{
	if (!SceneProxy)
		return new FDeformMeshSceneProxy(this);
	else
		return SceneProxy;
}
```

##### GetNumMaterials()
- 這是 override UPrimitiveComponent.h 裡面的函式
- 他有開個 private 的 `TArray<FDeformMeshSection> DeformMeshSections`，用來存 mesh sections
- 在這個函式中，會回傳有幾個 mesh sections
```cpp
int32 UDeformMeshComponent::GetNumMaterials() const
{
	return DeformMeshSections.Num();
}
```

##### CreateMeshSection()
- 先檢查 DeformMeshSections 夠不夠大
- reset 該 section
- 設定該 section 的 mesh 和 transform
- 更新該 section 的 SectionLocalBox


```cpp
void UDeformMeshComponent::CreateMeshSection(int32 SectionIndex, UStaticMesh* Mesh, const FTransform& Transform)
{
	// Ensure sections array is long enough
	if (SectionIndex >= DeformMeshSections.Num())
	{
		DeformMeshSections.SetNum(SectionIndex + 1, false);
	}

	// Reset this section (in case it already existed)
	FDeformMeshSection& NewSection = DeformMeshSections[SectionIndex];
	NewSection.Reset();

	// Fill in the mesh section with the needed data
	// I'm assuming that the StaticMesh has only one section and I'm only using that
	NewSection.StaticMesh = Mesh;
	NewSection.DeformTransform = Transform.ToMatrixWithScale().GetTransposed();

	//Update the local bound using the bounds of the static mesh that we're adding
	//I'm not taking in consideration the deformation here, if the deformation cause the mesh to go outside its bounds
	NewSection.StaticMesh->CalculateExtendedBounds();
	NewSection.SectionLocalBox += NewSection.StaticMesh->GetBoundingBox();

	//Add this sections' material to the list of the component's materials, with the same index as the section
	SetMaterial(SectionIndex, NewSection.StaticMesh->GetMaterial(0));
	

	UpdateLocalBounds(); // Update overall bounds
	MarkRenderStateDirty(); // New section requires recreating scene proxy
}
```

##### CalcBounds()
##### UpdateLocalBounds()
- 目前看起來是考慮所有 sections，更新整體的 bounds
- 他有開個 public 的 `FBoxSphereBounds LocalBounds`，用來存 Local space bounds of mesh
- UpdateBounds 是存在於 PrimitiveComponent.h 的函式
  - 更新 global bounds
- 下面的 MarkRenderTransformDirty() 是存在於 ActorComponents.h 的函式
  - Marks the transform as dirty - will be sent to the render thread at the end of the frame
```cpp
void UDeformMeshComponent::UpdateLocalBounds()
{
	FBox LocalBox(ForceInit);

	for (const FDeformMeshSection& Section : DeformMeshSections)
	{
		LocalBox += Section.SectionLocalBox;
	}

	LocalBounds = LocalBox.IsValid ? FBoxSphereBounds(LocalBox) : FBoxSphereBounds(FVector(0, 0, 0), FVector(0, 0, 0), 0); // fallback to reset box sphere bounds

	// Update global bounds
	UpdateBounds();
	// Need to send to render thread
	MarkRenderTransformDirty();
}
```

##### UpdateMeshSectionTransform()
- Update the Transform Matrix that we use to deform the mesh
- 他有開個 public 的 `FMatrix DeformTransform`，用來存 The secondary transform matrix that we'll use to deform this mesh section
- 會 Enque command 給 render thread，並呼叫 proxy 的 UpdateDeformTransform_RenderThread

```cpp
void UDeformMeshComponent::UpdateMeshSectionTransform(int32 SectionIndex, const FTransform& Transform)
{
	if (SectionIndex < DeformMeshSections.Num())
	{
		//Set game thread state (我還不知道這裡在幹嘛)
		const FMatrix TransformMatrix = Transform.ToMatrixWithScale().GetTransposed();
		DeformMeshSections[SectionIndex].DeformTransform = TransformMatrix;

		DeformMeshSections[SectionIndex].SectionLocalBox += DeformMeshSections[SectionIndex].StaticMesh->GetBoundingBox().TransformBy(Transform);


		if (SceneProxy)
		{
			// Enqueue command to modify render thread info
			FDeformMeshSceneProxy* DeformMeshSceneProxy = (FDeformMeshSceneProxy*)SceneProxy;
			ENQUEUE_RENDER_COMMAND(FDeformMeshTransformsUpdate)(
				[DeformMeshSceneProxy, SectionIndex, TransformMatrix](FRHICommandListImmediate& RHICmdList)
				{
					DeformMeshSceneProxy->UpdateDeformTransform_RenderThread(SectionIndex, TransformMatrix);
				});
		}
		UpdateLocalBounds();		 // Update overall bounds
		MarkRenderTransformDirty();  // Need to send new bounds to render thread
	}
}
```

##### UpdateDeformTransform_RenderThread()
- 檢查是否在 render thread 裡面
- 更新 `TArray<FMatrix> DeformTransforms`，並 mark `bool bDeformTransformsDirty` dirty
  - 這兩個都是開在 private 裡面
```cpp
void UpdateDeformTransform_RenderThread(int32 SectionIndex, FMatrix Transform)
{
    check(IsInRenderingThread());
    if (SectionIndex < Sections.Num() &&
        Sections[SectionIndex] != nullptr)
    {
        DeformTransforms[SectionIndex] = Transform;
        //Mark as dirty
        bDeformTransformsDirty = true;
    }
}
```

##### FinishTransformsUpdate()
- This method is called after we finished updating all the section transforms that we want to update
- This will update the structured buffer with the new transforms
- 會 Enque command 給 render thread，並呼叫 proxy 的 UpdateDeformTransformsSB_RenderThread
```cpp
void UDeformMeshComponent::FinishTransformsUpdate()
{
	if (SceneProxy)
	{
		// Enqueue command to modify render thread info
		FDeformMeshSceneProxy* DeformMeshSceneProxy = (FDeformMeshSceneProxy*)SceneProxy;
		ENQUEUE_RENDER_COMMAND(FDeformMeshAllTransformsSBUpdate)(
			[DeformMeshSceneProxy](FRHICommandListImmediate& RHICmdList)
			{
				DeformMeshSceneProxy->UpdateDeformTransformsSB_RenderThread();
			});
	}
}
```

##### UpdateDeformTransformsSB_RenderThread()
- 檢查是否在 render thread 裡面
- 他有開個 `FStructuredBufferRHIRef DeformTransformsSB`，看起來是把 DeformTransformsSB lock 後 copy，最後再 unlock

```cpp
void UpdateDeformTransformsSB_RenderThread()
{
    check(IsInRenderingThread());
    //Update the structured buffer only if it needs update
    if(bDeformTransformsDirty && DeformTransformsSB)
    {
        void* StructuredBufferData = RHILockStructuredBuffer(DeformTransformsSB, 0, DeformTransforms.Num() * sizeof(FMatrix), RLM_WriteOnly);
        FMemory::Memcpy(StructuredBufferData, DeformTransforms.GetData(), DeformTransforms.Num() * sizeof(FMatrix));
        RHIUnlockStructuredBuffer(DeformTransformsSB);
        bDeformTransformsDirty = false;
    }
}
```